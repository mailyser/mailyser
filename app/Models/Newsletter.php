<?php

namespace App\Models;

use App\Actions\GenerateNewsletterAudienceAction;
use App\Enums\NewsletterStatusEnum;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Support\Arr;
use Spatie\ModelStatus\HasStatuses;
use Illuminate\Support\Facades\Storage;

class Newsletter extends Model
{
    use HasFactory;
    use HasStatuses;

    protected $guarded = ['id'];

    protected $casts = [
        'scheduled_for' => 'datetime',
        'scanning_at' => 'datetime',
        'completed_at' => 'datetime',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function sender(): BelongsTo
    {
        return $this->belongsTo(Sender::class);
    }

    public function emails(): BelongsToMany
    {
        return $this
            ->belongsToMany(Email::class)
            ->withPivot([
                'status',
                'found_at_mailbox',
                'error',
            ]);
    }

    public static function audienceFields(): array
    {
        return [
            'first_name',
            'last_name',
            'email',
        ];
    }

    public function getMailTesterIdentifier() {
        return 'mailyser-newsletter'.$this->id;
            
    }
    
    public function getMailTestUniqueEmail() {
        return $this->getMailTesterIdentifier().'@srv1.mail-tester.com';
    }
    
    public function getOrGenerateAudience(): array
    {
        return $this->emails->count()
            ? $this->emails()->select(self::audienceFields())->get()->transform(function ($email) {
                return Arr::only($email->attributes, self::audienceFields());
            })->toArray()
            : app(GenerateNewsletterAudienceAction::class)($this);
    }

    public function finishedScanning(): bool
    {
        return $this->status === NewsletterStatusEnum::Finished->name;
    }
    
    public function processSpamScore() {
        $newsletterSpamScore = NewsletterSpamScore::where('newsletter_id', $this->id)->first();
        if($newsletterSpamScore) {
            if($newsletterSpamScore->is_processed == 0) {
                
                $spamData = $this->runSpamScore($newsletterSpamScore);
                if($spamData) {
                    $newsletterSpamScore->is_processed = 1;
                    $newsletterSpamScore->spam_score = $spamData['score'];
                    $newsletterSpamScore->spam_report = $spamData['report'];
                    $newsletterSpamScore->spam_rules = json_encode($spamData['rules']);
                    
                    $newsletterSpamScore->save();
                }
            }
            
            if($newsletterSpamScore->is_processed == 1)
                return $newsletterSpamScore;
            
        }
        return false;
    }
    
    private function runSpamScore($newsletterSpamScore) {
        $postParams = [];
        $postParams['email'] = $newsletterSpamScore->full_content;
        $postParams['options'] = "long";
        
        // Generated by curl-to-PHP: http://incarnate.github.io/curl-to-php/
        $ch = curl_init();
        
        curl_setopt($ch, CURLOPT_URL, 'https://spamcheck.postmarkapp.com/filter');
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_POST, 1);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($postParams));
        
        $headers = array();
        $headers[] = 'Accept: application/json';
        $headers[] = 'Content-Type: application/json';
        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
        
        $result = curl_exec($ch);
        if (curl_errno($ch)) {
            ;//echo 'Error:' . curl_error($ch);
        }
        curl_close($ch);
        $resp = json_decode($result, true);
//         var_dump($resp);
//         die;
//         echo $resp['score'];
//         echo $resp['report'];
        
        if(isset($resp['score']) && isset($resp['report'])) {
            return $resp;
        }
        return false;
    }
    
    public function getSpamInsights(){
        $insights = [];
        if (($open = fopen(storage_path() . "/spam-insights.csv", "r")) !== FALSE) {
            
            $isStart = false;
            while (($data = fgetcsv($open)) !== FALSE) {
                
                if($isStart) {
                    //$insights[] = ['rule' => trim($data[0]), 'insights' => trim($data[2])];
                    
                    $insights[trim($data[0])] = trim($data[2]);
                }else{
                    $isStart = true;
                }
                
            }
            
            
            fclose($open);
            
        }
        return $insights;
    }
    
    public function getMailtesterData() {
        $uniqueId =  $this->getMailTesterIdentifier();
        
        if(Storage::disk('local')->exists($this->getMailTesterIdentifier().'.json')) {
          $mailTestJson = json_decode(Storage::disk('local')->get($this->getMailTesterIdentifier().'.json'));
          
          return $mailTestJson;
        }
        
        $url = "https://www.mail-tester.com/".$uniqueId."&format=json";
        
        //  Initiate curl
        $ch = curl_init();
        // Will return the response, if false it print the response
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        // Set the url
        curl_setopt($ch, CURLOPT_URL,$url);
        // Execute
        $result=curl_exec($ch);
        // Closing
        curl_close($ch);
        
        // Will dump a beauty json :3
        $mailTestJson = (json_decode($result, true));
         
        if($mailTestJson && isset($mailTestJson['status']) && $mailTestJson['status']) {
          Storage::disk('local')->put($this->getMailTesterIdentifier().'.json', json_encode($mailTestJson));
        }
        
        return $mailTestJson;
      
    }
}
